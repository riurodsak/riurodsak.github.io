<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="A couple of weeks ago I had the chance to attend the Mathematics for Governance Design Workshop, where we explored avenues of collaboration between social scientists and category theorists in the task of modelling social dynamics and design of governance structures. Others are writing about the open games engine, but I wanted to focus on an idea that I discussed with Michael &ldquo;Z&rdquo; Zargham and David Spivak about systems engineering design and lenses.
"><meta name=keywords content="homepage,blog,Riu Rodriguez Sakamoto,Bidirectional processes,Poly,Systems engineering"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://riurodsak.github.io/posts/2024/10/concept-selection-in-systems-engineering-as-lenses-in-poly/><title>Concept selection in systems engineering as lenses in Poly :: Riu Rodríguez Sakamoto
</title><link rel=stylesheet href=/main.949191c1dcc9c4a887997048b240354e47152016d821198f89448496ba42e491.css integrity="sha256-lJGRwdzJxKiHmXBIskA1TkcVIBbYIRmPiUSElrpC5JE="><link rel=stylesheet type=text/css href=https://riurodsak.github.io/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Concept selection in systems engineering as lenses in Poly"><meta itemprop=description content="A couple of weeks ago I had the chance to attend the Mathematics for Governance Design Workshop, where we explored avenues of collaboration between social scientists and category theorists in the task of modelling social dynamics and design of governance structures. Others are writing about the open games engine, but I wanted to focus on an idea that I discussed with Michael “Z” Zargham and David Spivak about systems engineering design and lenses."><meta itemprop=datePublished content="2024-10-23T16:14:33+01:00"><meta itemprop=dateModified content="2024-10-23T16:14:33+01:00"><meta itemprop=wordCount content="1235"><meta itemprop=image content="https://riurodsak.github.io/"><meta itemprop=keywords content="Bidirectional Processes, Poly, Systems Engineering"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://riurodsak.github.io/"><meta name=twitter:title content="Concept selection in systems engineering as lenses in Poly"><meta name=twitter:description content="A couple of weeks ago I had the chance to attend the Mathematics for Governance Design Workshop, where we explored avenues of collaboration between social scientists and category theorists in the task of modelling social dynamics and design of governance structures. Others are writing about the open games engine, but I wanted to focus on an idea that I discussed with Michael “Z” Zargham and David Spivak about systems engineering design and lenses."><meta property="article:published_time" content="2024-10-23 16:14:33 +0100 +0100"><!doctype html><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script defer>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1}]})})</script></head></html><link rel=stylesheet type=text/css href=/css/hugo-cite.css></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>/home</span>
<span class=logo__cursor style=visibility:hidden></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>Blog</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 minutes</p></div><article><h1 class=post-title><a href=https://riurodsak.github.io/posts/2024/10/concept-selection-in-systems-engineering-as-lenses-in-poly/>Concept selection in systems engineering as lenses in Poly</a></h1><div class=post-content><p>A couple of weeks ago I had the chance to attend the <a href=https://www.icms.org.uk/GovernanceDesign>Mathematics for Governance Design</a> Workshop, where we explored avenues of collaboration between social scientists and category theorists in the task of modelling social dynamics and design of governance structures.
Others are writing about the open games engine, but I wanted to focus on an idea that I discussed with <a href=https://www.block.science/>Michael &ldquo;Z&rdquo; Zargham</a> and <a href=http://www.dspivak.net/>David Spivak</a> about systems engineering design and lenses.</p><h1 id=systems-engineering>Systems engineering</h1><p>In traditional systems engineering, the system requirements, design and implementation details were captured in textual documents.
This often led to inconsistency and redundancy in some large projects.</p><p>The modernization to the current model-based approach was made possible among other factors by system modeling languages, such as SysML, an extension of software&rsquo;s UML that allows structured, visual representation of behaviour, architecture and requirements.</p><p>In addition to traditional (by which I mean Java-centric) general system modeling languages such as <a href=https://docs.nomagic.com/display/CSM2024xR1>Cameo Systems Modeler</a> or <a href=https://www.modelio.org/index.htm>ModelIO</a>, there are many new system modeling languages emerging that serve both as a visualization tool and also leverage the foundations of systems theory (<a href=https://topos.site/blog/2024-10-02-introducing-catcolab/>one</a> just this month!).
My aim here is to prototype a modeling language that</p><ul><li>has both a visual representation via string diagrams and static analysis via basic types or attributes</li><li>aids in the concept design and concept selection steps of the project&rsquo;s lifecycle.</li></ul><h1 id=system-processes-as-lenses>System processes as lenses</h1><p>Design interfaces seem to always be bidirectional: there are some requirements as inputs, and value/products as outputs. The sketch that &ldquo;Z&rdquo; showed me was something like the following:</p><p><img src=system_architecture_lens.svg#svgstyle alt="System architecture lens"></p><p>where the high level interface on the left gets translated to a low level interface on the right.
An example is NASA&rsquo;s <a href=https://nodis3.gsfc.nasa.gov/npg_img/N_PR_7123_001B_/NPR7123.1BC3G1.png>&ldquo;Systems Engineering Engine&rdquo;</a>, which can be depicted in some greater detail as:</p><p><img src=NASA_engine_lens.svg#svgstyle alt="NASA SE Engine lens"></p><p>where the two maps refer to processes related to &ldquo;system design&rdquo;, and &ldquo;product realization & technical management&rdquo;.
One structure originating in functional programming with this interface is a lens.
A lens from an interface ${A\choose B}$ to another ${C\choose D}$, written $\lambda\in\mathrm{Lens}({A\choose B},{C\choose D})$, is a bidirectional map characterized by a forward map $v:A\to C$ and a backward map $u:A\times D\to B$.
They form a monoidal category, and have a formal graphical syntax similar to the one shown above. Their parallel (monoidal) composition serves as juxtaposition of independent subprocesses, and sequential composition acts as a &ldquo;wrapper interface&rdquo;.</p><p>Consider a set of requirements $R$ for an expected product $P$.
One may know that $R$ can be decomposed into two independent sets of requirements $S_1,S_2$, for subproducts $Q_1,Q_2$ respectively.
Suppose these two processes of creating the subproducts $Q_1,Q_2$ out of $S_1,S_2$ cannot be decomposed further, and we know how to create them (e.g. the definition of functions $u_i:S_i\to Q_i$ is known).
These can be encoded as $\mathrm{Lens}({R\choose P},{S_1\times S_2\choose Q_1\times Q_2})$ composed with $\mathrm{Lens}({S_i\choose Q_i},{1\choose 1})$, depicted in the following diagram:</p><p><img src=product_example.svg#svgstyle alt="Product decomposition example"></p><p>This coupling the feedback of execution to the process itself has two effects:</p><ul><li>an overhead to the process design. Every process that transforms a product&rsquo;s requirement into smaller pieces has to describe how the subproducts realization satisfy the initial requirement.</li><li>a simplification of <em>some</em> requirement verifications by composition of compatible interfaces. It modularizes the question &ldquo;Does this system satisfy the stakeholder&rsquo;s requirements?&rdquo; into subproblems of checking whether the definition of the functions $u_i$ satisfy their declared type $S_i\to Q_i$.</li></ul><p>My conjecture is that the improvements coming from the second point overcome the overhead of the first in concept design. Specialization from function to form.
As with every framework, its misuse or application outside its intended scope might lead to redundant or unnatural boilerplate, but it forces at least to think about every components intended purpose and contribution to the overall goal.</p><h1 id=lenses-in-poly-and-dynamic-wiring-diagrams>Lenses in Poly and dynamic wiring diagrams</h1><p>The second point to address is the aid in concept design and selection.
Once a system model is defined, the verification process is straight forward, but how do we come up with the model itself?
One possibility is to define an initial guess of a wiring diagram like the one above and define rewiring operations (e.g. to optimize some metric).
In the framework of $\mathrm{Poly}$, this corresponds to the horizontal morphisms of $\mathbb{O}\mathrm{rg}$, i.e. $[p,q]$-coalgebras, which were introduced to model &ldquo;dynamic wiring diagrams&rdquo; by Shapiro and Spivak [<a href=https://arxiv.org/abs/2205.03906>1</a>].</p><p>The usual way of understanding the relation between $\mathrm{Lens}$ and $\mathrm{Poly}$ is by the traditional &ldquo;data-accessor&rdquo; interpretation of lenses, which correspond to wiring diagrams: for a lens $\lambda:{A\choose B}\rightleftarrows{C\choose D}$, it&rsquo;s forward map $v$ <em>views</em> part $B$ of a data structure $A$, and it&rsquo;s backward map $u$ <em>updates</em> the datastructure $A$ with a new part $D$. This is exactly a morphism $Ay^B\to Cy^D$ in $\mathrm{Poly}$.
The last string diagram above might be written as the composition of $\mathrm{Poly}(Ry^P,S_1y^{Q_1}\otimes S_2y^{Q_2})$ with $\mathrm{Poly}(S_iy^{Q_i},y)$.</p><p>However, I want to make explicit the constructor of lenses internally to $\mathrm{Poly}$, by considering the morphism
$$ \mathrm{mkLens}:\mathrm{Poly}(Cy^A\otimes By^{AD}, CBy^{AD}) $$
$\mathrm{mkLens}(v,u)$ is a monomial with inputs (positions) $C\times B$ and outputs (directions) $A\times D$ arising from the composition of a view map $v\in Cy^A$ and an update map $u\in By^{AD}$, i.e. as the image of a particular wiring diagram that sends $(v,u)\mapsto A^2y^A\triangleleft (v\otimes u)$.</p><p>The reason for this embedding of lenses is to make a distinction between morphisms in $\mathrm{Poly}$ that are structural, and others that are computational.
Given a set of $I$ different subprocesses/legacy products/COTS components (one might call it a &ldquo;knowledge base&rdquo;), a dynamical system that enables <strong>concept selection</strong> would be the morphism:</p><p>$$ Sy^S \to [\bigotimes_{i\in I}\mathrm{mkLens}(v_i,u_i), Ry^P] $$</p><p>This is an example of a $[p,q]$-coalgebra.</p><h1 id=api-and-search-heuristics>API and search heuristics</h1><p>This sketches an idealized tool where the user provides pairs of (process, feedback) that get converted to a lens wiring diagram.
The proposed composition of them would be the initial state of the $[p,q]$-coalgebra.
The tool then checks the type compatibility between them, and suggests alternative wirings via the coalgebra evolution.</p><p>The difficulties from both the practice and theory sides are aligned:</p><ul><li>Composition of system processes is &ldquo;easy&rdquo;: verifying that certain processes achieve an overall requirements specification is modularized, and is realized by construction if formalized via a rich enough type system.</li><li>Decomposition of system processes is hard: coming up with a suitable set of processes that accomplish an initial task is performed by heuristics from an experienced systems engineer, and in theory it is a search problem as hard as the word problem.</li></ul><p>However, this last point might in practice not be as hard as it sounds; while for randomly generated system processes it might be hard, the system processes designed by engineers are hardly random.
Incorporating search heuristics from experts also has a compounding benefit over development of similar products.
Reducing the search space and approximating solutions via search heuristics from experts and Deep Learning methods are also strategies employed in many other fields that can be applicable here too.</p><p>Just the type compatibility would be a modernization of current system modeling tools.
But building new tools is not always the most important part; one creates an ecosystem which might be efficient internally, but what use does it have to outsiders?
This was one of the motivations that got me into category theory in the first place.
While in some fields this can only be done by being efficient communicators, applied category theory has some tools to tackle this problem in a slightly more systematic way, and it is something that I find beautiful about parsers, compilers, and learning other human languages.</p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://riurodsak.github.io/tags/bidirectional-processes-poly-systems-engineering/>Bidirectional processes, Poly, Systems engineering</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-10-23 15:14</p></div><div class=pagination><div class=pagination__buttons><span class="button next"><a href=https://riurodsak.github.io/posts/2024/05/rl_cat_cyb/><span class=button__text>Reinforcement Learning through the lens of Categorical Cybernetics</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span><a href=https://riurodsak.github.io/posts/index.xml target=_blank title=rss><svg width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span></div></div></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>